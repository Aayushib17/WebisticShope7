{"ast":null,"code":"import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n    end = boundaries.end;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  while (stepsize <= result.length) {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n    // Break condition - If we have evaluate all the ticks, then we are done.\n    if (entry === undefined) {\n      return getEveryNthWithCondition(ticks, stepsize);\n    }\n\n    // Check if the element collides with the next element\n    var size = getTickSize(entry, index);\n    var tickCoord = entry.coordinate;\n    // We will always show the first tick.\n    var isShow = index === 0 || isVisible(sign, tickCoord, size, start, end);\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (size / 2 + minTickGap);\n      index += stepsize;\n    }\n  }\n  return [];\n}","map":{"version":3,"names":["isVisible","getEveryNthWithCondition","getEquidistantTicks","sign","boundaries","getTickSize","ticks","minTickGap","result","slice","initialStart","start","end","index","stepsize","length","entry","undefined","size","tickCoord","coordinate","isShow"],"sources":["C:/Users/HP/node_modules/recharts/es6/cartesian/getEquidistantTicks.js"],"sourcesContent":["import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n    end = boundaries.end;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  while (stepsize <= result.length) {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n    // Break condition - If we have evaluate all the ticks, then we are done.\n    if (entry === undefined) {\n      return getEveryNthWithCondition(ticks, stepsize);\n    }\n\n    // Check if the element collides with the next element\n    var size = getTickSize(entry, index);\n    var tickCoord = entry.coordinate;\n    // We will always show the first tick.\n    var isShow = index === 0 || isVisible(sign, tickCoord, size, start, end);\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (size / 2 + minTickGap);\n      index += stepsize;\n    }\n  }\n  return [];\n}"],"mappings":"AAAA,SAASA,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,wBAAwB,QAAQ,kCAAkC;AAC3E,OAAO,SAASC,mBAAmBA,CAACC,IAAI,EAAEC,UAAU,EAAEC,WAAW,EAAEC,KAAK,EAAEC,UAAU,EAAE;EACpF,IAAIC,MAAM,GAAG,CAACF,KAAK,IAAI,EAAE,EAAEG,KAAK,CAAC,CAAC;EAClC,IAAIC,YAAY,GAAGN,UAAU,CAACO,KAAK;IACjCC,GAAG,GAAGR,UAAU,CAACQ,GAAG;EACtB,IAAIC,KAAK,GAAG,CAAC;EACb;EACA;EACA,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIH,KAAK,GAAGD,YAAY;EACxB,OAAOI,QAAQ,IAAIN,MAAM,CAACO,MAAM,EAAE;IAChC;IACA;;IAEA,IAAIC,KAAK,GAAGV,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACO,KAAK,CAAC;;IAEtE;IACA,IAAIG,KAAK,KAAKC,SAAS,EAAE;MACvB,OAAOhB,wBAAwB,CAACK,KAAK,EAAEQ,QAAQ,CAAC;IAClD;;IAEA;IACA,IAAII,IAAI,GAAGb,WAAW,CAACW,KAAK,EAAEH,KAAK,CAAC;IACpC,IAAIM,SAAS,GAAGH,KAAK,CAACI,UAAU;IAChC;IACA,IAAIC,MAAM,GAAGR,KAAK,KAAK,CAAC,IAAIb,SAAS,CAACG,IAAI,EAAEgB,SAAS,EAAED,IAAI,EAAEP,KAAK,EAAEC,GAAG,CAAC;IACxE,IAAI,CAACS,MAAM,EAAE;MACX;MACAR,KAAK,GAAG,CAAC;MACTF,KAAK,GAAGD,YAAY;MACpBI,QAAQ,IAAI,CAAC;IACf;IACA,IAAIO,MAAM,EAAE;MACV;MACAV,KAAK,GAAGQ,SAAS,GAAGhB,IAAI,IAAIe,IAAI,GAAG,CAAC,GAAGX,UAAU,CAAC;MAClDM,KAAK,IAAIC,QAAQ;IACnB;EACF;EACA,OAAO,EAAE;AACX"},"metadata":{},"sourceType":"module","externalDependencies":[]}